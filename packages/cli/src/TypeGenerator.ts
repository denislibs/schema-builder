import fs from 'fs/promises';
import path from 'path';
import type { DatabaseSchema, DatabaseTable, DatabaseColumn, GenerateOptions } from './types/generator.js';

export class TypeGenerator {
  constructor(private schema?: DatabaseSchema) {}

  async generateTypes(schema?: DatabaseSchema, options: GenerateOptions = {}): Promise<string> {
    const targetSchema = schema || this.schema;
    if (!targetSchema) {
      throw new Error('No schema provided');
    }

    const {
      format = 'interfaces',
      includeComments = true,
      exportStyle = 'named',
      camelCase = true,
      addTimestamps = true,
      addRelations = false
    } = options;

    let output = '';

    // Добавляем заголовок
    if (includeComments) {
      output += this.generateHeader();
    }

    // Генерируем enums
    if (targetSchema.enums.length > 0) {
      output += this.generateEnums(targetSchema.enums, exportStyle);
    }

    // Генерируем типы для таблиц
    for (const table of targetSchema.tables) {
      switch (format) {
        case 'types':
          output += this.generateTypeAlias(table, { camelCase, addTimestamps, addRelations, exportStyle });
          break;
        case 'interfaces':
          output += this.generateInterface(table, { camelCase, addTimestamps, addRelations, exportStyle });
          break;
        case 'classes':
          output += this.generateClass(table, { camelCase, addTimestamps, addRelations, exportStyle });
          break;
        case 'zod':
          output += this.generateZodSchema(table, { camelCase, addTimestamps, exportStyle });
          break;
      }
    }

    // Генерируем вспомогательные типы
    output += this.generateUtilityTypes(exportStyle);

    return output;
  }

  async saveToFile(outputPath: string, schema?: DatabaseSchema, options: GenerateOptions = {}): Promise<void> {
    const content = await this.generateTypes(schema, options);
    
    // Создаем директорию если не существует
    const dir = path.dirname(outputPath);
    await fs.mkdir(dir, { recursive: true });
    
    // Записываем файл
    await fs.writeFile(outputPath, content, 'utf8');
  }

  private generateHeader(): string {
    const timestamp = new Date().toISOString();
    return `/**
 * Auto-generated TypeScript definitions
 * Generated at: ${timestamp}
 * 
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 * This file is automatically generated from your database schema.
 * To regenerate, run: pg-migrate generate:types
 */

`;
  }

  private generateEnums(enums: Array<{ name: string; values: string[] }>, exportStyle: string): string {
    let output = '// ===== ENUMS =====\n\n';

    for (const enumDef of enums) {
      const enumName = this.toPascalCase(enumDef.name);
      const exportKeyword = exportStyle === 'named' ? 'export ' : '';
      
      output += `${exportKeyword}enum ${enumName} {\n`;
      
      for (const value of enumDef.values) {
        const key = this.toEnumKey(value);
        output += `  ${key} = '${value}',\n`;
      }
      
      output += '}\n\n';

      // Добавляем тип-юнион
      const unionName = `${enumName}Type`;
      const unionValues = enumDef.values.map(v => `'${v}'`).join(' | ');
      output += `${exportKeyword}type ${unionName} = ${unionValues};\n\n`;
    }

    return output;
  }

  private generateInterface(table: DatabaseTable, options: any): string {
    const interfaceName = this.toPascalCase(table.table_name);
    const exportKeyword = options.exportStyle === 'named' ? 'export ' : '';
    
    let output = `${exportKeyword}interface ${interfaceName} {\n`;

    for (const column of table.columns) {
      const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
      const tsType = this.mapPostgreSQLToTypeScript(column);
      const optional = column.is_nullable === 'YES' || column.column_default !== null ? '?' : '';
      
      // Добавляем комментарий с информацией о колонке
      output += `  /** ${column.data_type}`;
      if (column.is_primary_key) output += ' (Primary Key)';
      if (column.is_foreign_key) output += ` (Foreign Key -> ${column.foreign_table}.${column.foreign_column})`;
      if (column.character_maximum_length) output += ` (max: ${column.character_maximum_length})`;
      output += ' */\n';
      
      output += `  ${propName}${optional}: ${tsType};\n`;
    }

    // Добавляем отношения если требуется
    if (options.addRelations) {
      output += this.generateRelations(table, options);
    }

    output += '}\n\n';

    // Генерируем вспомогательные типы
    output += this.generateTableSpecificTypes(table, interfaceName, options);

    return output;
  }

  private generateTypeAlias(table: DatabaseTable, options: any): string {
    const typeName = this.toPascalCase(table.table_name);
    const exportKeyword = options.exportStyle === 'named' ? 'export ' : '';
    
    let output = `${exportKeyword}type ${typeName} = {\n`;

    for (const column of table.columns) {
      const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
      const tsType = this.mapPostgreSQLToTypeScript(column);
      const optional = column.is_nullable === 'YES' || column.column_default !== null ? '?' : '';
      
      output += `  ${propName}${optional}: ${tsType};\n`;
    }

    output += '};\n\n';

    return output;
  }

  private generateClass(table: DatabaseTable, options: any): string {
    const className = this.toPascalCase(table.table_name);
    const exportKeyword = options.exportStyle === 'named' ? 'export ' : '';
    
    let output = `${exportKeyword}class ${className} {\n`;

    // Свойства
    for (const column of table.columns) {
      const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
      const tsType = this.mapPostgreSQLToTypeScript(column);
      const optional = column.is_nullable === 'YES' || column.column_default !== null ? '?' : '';
      
      output += `  ${propName}${optional}: ${tsType};\n`;
    }

    output += '\n';

    // Конструктор
    output += `  constructor(data: Partial<${className}> = {}) {\n`;
    for (const column of table.columns) {
      const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
      output += `    this.${propName} = data.${propName};\n`;
    }
    output += '  }\n\n';

    // Метод toJSON
    output += '  toJSON() {\n';
    output += '    return {\n';
    for (const column of table.columns) {
      const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
      output += `      ${propName}: this.${propName},\n`;
    }
    output += '    };\n';
    output += '  }\n';

    output += '}\n\n';

    return output;
  }

  private generateZodSchema(table: DatabaseTable, options: any): string {
    const schemaName = `${this.toCamelCase(table.table_name)}Schema`;
    const exportKeyword = options.exportStyle === 'named' ? 'export ' : '';
    
    let output = `${exportKeyword}const ${schemaName} = z.object({\n`;

    for (const column of table.columns) {
      const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
      const zodType = this.mapPostgreSQLToZod(column);
      
      output += `  ${propName}: ${zodType},\n`;
    }

    output += '});\n\n';

    // Генерируем тип из схемы
    const typeName = this.toPascalCase(table.table_name);
    output += `${exportKeyword}type ${typeName} = z.infer<typeof ${schemaName}>;\n\n`;

    return output;
  }

  private generateRelations(table: DatabaseTable, options: any): string {
    let output = '\n  // Relations\n';
    
    // Внешние ключи (belongsTo)
    for (const fk of table.foreign_keys) {
      const relationName = options.camelCase ? this.toCamelCase(fk.foreign_table) : fk.foreign_table;
      const relationType = this.toPascalCase(fk.foreign_table);
      output += `  ${relationName}?: ${relationType};\n`;
    }

    // TODO: Обратные связи (hasMany) - требует анализа всех таблиц
    
    return output;
  }

  private generateTableSpecificTypes(table: DatabaseTable, interfaceName: string, options: any): string {
    const exportKeyword = options.exportStyle === 'named' ? 'export ' : '';
    let output = '';

    // Create type (без автогенерируемых полей)
    const createFields = table.columns.filter(col => 
      !col.is_primary_key || 
      !col.column_default?.includes('nextval')
    );

    if (createFields.length < table.columns.length) {
      output += `${exportKeyword}type Create${interfaceName} = {\n`;
      for (const column of createFields) {
        const propName = options.camelCase ? this.toCamelCase(column.column_name) : column.column_name;
        const tsType = this.mapPostgreSQLToTypeScript(column);
        const optional = column.is_nullable === 'YES' || column.column_default !== null ? '?' : '';
        output += `  ${propName}${optional}: ${tsType};\n`;
      }
      output += '};\n\n';
    }

    // Update type (все поля опциональные кроме ID)
    output += `${exportKeyword}type Update${interfaceName} = Partial<${interfaceName}>;\n\n`;

    // Where type (для поиска)
    output += `${exportKeyword}type ${interfaceName}Where = Partial<${interfaceName}>;\n\n`;

    return output;
  }

  private generateUtilityTypes(exportStyle: string): string {
    const exportKeyword = exportStyle === 'named' ? 'export ' : '';
    
    return `
// ===== UTILITY TYPES =====

${exportKeyword}type DatabaseRow = {
  [key: string]: any;
};

${exportKeyword}type QueryResult<T> = {
  rows: T[];
  rowCount: number;
};

${exportKeyword}type PaginationOptions = {
  page?: number;
  limit?: number;
  offset?: number;
};

${exportKeyword}type SortOptions = {
  orderBy?: string;
  direction?: 'ASC' | 'DESC';
};

${exportKeyword}type QueryOptions = PaginationOptions & SortOptions;

`;
  }

  private mapPostgreSQLToTypeScript(column: DatabaseColumn): string {
    const { data_type, is_nullable } = column;
    let tsType: string;

    switch (data_type.toLowerCase()) {
      case 'integer':
      case 'bigint':
      case 'smallint':
      case 'decimal':
      case 'numeric':
      case 'real':
      case 'double precision':
      case 'serial':
      case 'bigserial':
        tsType = 'number';
        break;

      case 'character varying':
      case 'varchar':
      case 'character':
      case 'char':
      case 'text':
        tsType = 'string';
        break;

      case 'boolean':
        tsType = 'boolean';
        break;

      case 'timestamp':
      case 'timestamp with time zone':
      case 'timestamp without time zone':
      case 'date':
      case 'time':
        tsType = 'Date | string';
        break;

      case 'json':
      case 'jsonb':
        tsType = 'Record<string, any>';
        break;

      case 'uuid':
        tsType = 'string';
        break;

      case 'bytea':
        tsType = 'Buffer';
        break;

      case 'array':
      case 'text[]':
      case 'integer[]':
      case 'varchar[]':
        const arrayType = data_type.includes('text') || data_type.includes('varchar') ? 'string' : 'any';
        tsType = `${arrayType}[]`;
        break;

      default:
        // Проверяем на enum
        if (this.schema.enums.some(e => e.name === data_type)) {
          tsType = this.toPascalCase(data_type);
        } else {
          tsType = 'any';
        }
    }

    // Добавляем null если поле nullable
    if (is_nullable === 'YES') {
      tsType += ' | null';
    }

    return tsType;
  }

  private mapPostgreSQLToZod(column: DatabaseColumn): string {
    const { data_type, is_nullable, character_maximum_length } = column;
    let zodType: string;

    switch (data_type.toLowerCase()) {
      case 'integer':
      case 'bigint':
      case 'smallint':
      case 'serial':
      case 'bigserial':
        zodType = 'z.number().int()';
        break;

      case 'decimal':
      case 'numeric':
      case 'real':
      case 'double precision':
        zodType = 'z.number()';
        break;

      case 'character varying':
      case 'varchar':
      case 'character':
      case 'char':
      case 'text':
        zodType = 'z.string()';
        if (character_maximum_length) {
          zodType += `.max(${character_maximum_length})`;
        }
        break;

      case 'boolean':
        zodType = 'z.boolean()';
        break;

      case 'timestamp':
      case 'timestamp with time zone':
      case 'timestamp without time zone':
      case 'date':
        zodType = 'z.string().datetime()';
        break;

      case 'time':
        zodType = 'z.string()';
        break;

      case 'json':
      case 'jsonb':
        zodType = 'z.record(z.any())';
        break;

      case 'uuid':
        zodType = 'z.string().uuid()';
        break;

      case 'array':
      case 'text[]':
      case 'integer[]':
        const arrayType = data_type.includes('text') ? 'z.string()' : 'z.any()';
        zodType = `z.array(${arrayType})`;
        break;

      default:
        if (this.schema.enums.some(e => e.name === data_type)) {
          const enumValues = this.schema.enums.find(e => e.name === data_type)?.values || [];
          zodType = `z.enum([${enumValues.map(v => `'${v}'`).join(', ')}])`;
        } else {
          zodType = 'z.any()';
        }
    }

    // Добавляем nullable если поле может быть null
    if (is_nullable === 'YES') {
      zodType += '.nullable()';
    }

    // Добавляем optional если есть default
    if (column.column_default !== null) {
      zodType += '.optional()';
    }

    return zodType;
  }

  private toPascalCase(str: string): string {
    return str
      .split(/[_\s-]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private toCamelCase(str: string): string {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  private toEnumKey(value: string): string {
    return value
      .toUpperCase()
      .replace(/[^A-Z0-9]/g, '_')
      .replace(/^(\d)/, '_$1'); // Если начинается с цифры
  }
}
